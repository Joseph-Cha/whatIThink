# 객체 지향 (Object Oriented Programming)

## 객체 지향 프로그래밍이 뭘까?
[객체지향](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)은
OOP는 컴퓨터 프로그래밍의 패러다임 중 하나로, 프로그램을 명령어의 목록으로 보는 시각에서 벗어나<br>
여러 개의 독립된 단위인 객체들의 모임으로 파악하고 하는 것이라 한다.<br>
>즉, 프로그래밍에서 필요한 데이터를 **추상화**시켜 **상태**와 **행위**를 가진 **객체**를 만들고,<br>
그 객체들간의 **유기적인 상호작용**을 통해 로직을 구성하는 프로그래밍 방법이다.<br>

## 객체 지향 vs 절차 지향
두 가지를 비교하기 위해서 대표적인 예시를 들어보자.<br>

```
자동차를 만들기 위해서는 엔진, 핸들, 바퀴, 의자, 엑셀, 브레이크 등 많은 부품이 필요하다.
기존의 절차 지향 방식의 관점에서 자동차를 만드는 방법은
엔진 -> 차체 -> 의자 -> 핸들 .. 식의 순서가 달라져서도 안되고 서로 분리되서는 안되며
하나가 고장나면 전체 기능이 멈추도록 설계 된 것과 비슷하다고 생각할 수 있다.
다른 종류의 부품으로도 대체 불가능 하다는 전제도 포함한다면 비효율적이고 비생산적이다.

객체지향의 관점이라면 자동차를 만들기 까지의 과정에서 순서는 상관 없다.
각각 독립적으로 만들어져 하나로 조립되고 각각의 기능만 잘 수행하면 된다.
하나의 부품이 고장나더라도 다른 부분은 영향 받지 않고 그저 문제가 있는 부분만 고치면 된다.
```
순차적인 처리 방식으로 프로그램 전체가 유기적으로 연결되어야 하는 경우에는 객체 지향 언어에 비해 절차 지향 방식이 빨리 처리될 것이다.<br>
그러나 기술이 발전함에 따라 하드웨어가 소프트웨어의 발달 속도보다 더뎌지면서 객체지향언어가 등장하고 중요해졌다.<br>
하드웨어가 같은 기능을 중복으로 연산하도록 하지 않고 모듈을 재활용하기 때문에 하드웨어의 처리량이 획기적으로 줄어들었기 때문이다.<br>

## 객체 지향 프로그래밍의 장, 단점
### 장점
- **코드 재사용**이 용이하다.<br>
클래스를 가져와 사용할 수 있고 상속을 통해 확장하여 사용 가능하다.

- **유지보수**가 쉽다.<br>
각각의 객체는 메시지를 주고 받고, 데이터를 처리하기에 프로그램을 유연하고, 변경이 용이하게 만든다.<br>
수정해야하는 부분이 클래스 내부에 멤버 변수나 메서드로 있기때문에 해당 부분만 수정가능하다.

- **대형프로젝트**에 적합하다.<br>
클래스 단위로 모듈화가능하므로 다수의 개발자가 협업 시 분담이 쉽다.

### 단점

- 처리속도가 상대적으로 느리다.<br>

- 객체의 수가 늘어나면 용량이 늘어난다.<br>

- 설계시 시간과 노력이 많이 필요하다.<br>

## 객체 지향 프로그래밍 키워드 5가지

1. **클래스와 인스턴스(객체)**<br>
문제해결을 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(attribute)과 행위(behavior)를 변수와 매서드로 정의한 것.<br>
`속성 -(추상화)-> 변수` `행위 -(추상화)-> 메서드`<br>

2. **추상화**<br>
불필요한 정보는 숨기고 중요한 정보만 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것.<br>
객체지향 관점에서 클래스를 정의하는 것.

3. **캡슐화**<br>
코드를 재수정없이 재활용하기 위해 관련된 기능과 특성을 한 곳에 모으로 분류하는 것.<br>
객체 지향 프로그래밍에서 기능과 특성의 모음을 클래스라는 캡슐에 분류해서 넣는 것이 캡슐화이다.<br>
캡슐화는 추상화와 거의 같은 개념이지만 추상화를 지원하며 보다 구체적이고 제한적이라 할 수 있다.<br>

4. **상속**<br>
부모클래스의 속성과 기능을 그대로 이어받아 사용하고, 자식클래스에서 변경이 필요한 부분만 다시 정의할 수 있는 것.<br>
다중상속은 혼란을 야기할 수 있으므로 반드시 하나만 가능하다.<br>
절차 지향 프로그래밍에서도 라이브러리를 통해 다른 소스코드를 가져와 사용하는 것이 가능하지만,<br>
수정하게되면 다른 라이브러리가 되어 동작하지 않거나 불필요한 코드를 수정해야하는 경우가 있다.<br>

5. **다형성**<br>
같은 모양의 코드가 다른 행위를 하는 것.<br>
하나의 변수, 함수 이름이 상황에 따라 다른 의미로 해석 될 수 있는 것이다.
- overriding<br>
부모 클래스에서 상속받은 메소드를 자식 클레스에서 같은 이름, 같은 반환값, 값은 인자로<br>
메소드 내의 로직들을 새롭게 정의하는 것.<br>
- overloading<br>
하나의 클래스에서 같은 이름으로 여러개의 메소드를 가지는 것.<br>
인자들의 타입이나 개수를 다르게 하면 어떤 메소드를 호출할 지 컴파일러가 알 수 있다.<br>

## 객체지향의 5원칙 (SOLID)
1. SRP(단일 책임의 원칙Single Responsibility Principle)
2. OCP (개방폐쇄의 원칙: Open Close Principle)
3. LSP (리스코브 치환의 원칙: The Liskov Substitution Principle)
4. ISP (인터페이스 분리의 원칙: Interface Segregation Principle)
5. DIP (의존성역전의 원칙: Dependency Inversion Principle)
